# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/02_functions.ipynb (unless otherwise specified).

__all__ = ['BaseFunction', 'Variable', 'Constant', 'Subtract', 'Proportional', 'Integration', 'PCTNode', 'PCTNodeData']

# Cell
from abc import ABC, abstractmethod

# Cell
class BaseFunction(ABC):
    "Base class of a PCT function."
    def __init__(self, name):
        self.value = 0
        self.links = []
        self.name = name

    @abstractmethod
    def __call__(self, verbose=False):
        if verbose :
            print(f'{self.value}', end= " ")

        return self.value

    @abstractmethod
    def summary(self, str):
        print(f'{self.name} {type(self).__name__} ', end = " ")
        if len(str)>0:
            print(f'| {str}', end= " ")
        print(f'| {self.value}', end = " ")
        if len(self.links)>0:
            print(f'| links ', end=" ")
        for link in self.links:
            print(link.get_name(), end= " ")
        print()

    def get_name(self):
        return self.name

    def set_name(self, name):
        self.name=name

    def set_value(self, value):
        self.value= value

    def get_value(self):
        return self.value

    def add_link(self, linkfn):
        self.links.append(linkfn)


# Cell
class Variable(BaseFunction):
    "A function that returns a variable value."
    def __init__(self, variable, name="variable"):
        super().__init__(name)
        self.value = variable

    def __call__(self, verbose=False):
        return super().__call__(verbose)

    def summary(self):
        super().summary("")


# Cell
class Constant(BaseFunction):
    "A function that returns a constant value."
    def __init__(self, constant, name="constant"):
        super().__init__(name)
        self.value = constant

    def __call__(self, verbose=False):
        return super().__call__(verbose)

    def summary(self):
        super().summary("")


# Cell
class Subtract(BaseFunction):
    "A function that subtracts one value from another."
    def __init__(self, name="subtract"):
        super().__init__(name)

    def __call__(self, verbose=False):
        #print("Sub ", self.links[0].get_value(),self.links[1].get_value() )
        self.value = self.links[0].get_value()-self.links[1].get_value()

        return super().__call__(verbose)

    def summary(self):
        super().summary("")


# Cell
class Proportional(BaseFunction):
    "Proportional function."
    def __init__(self, gain, name="proportional"):
        super().__init__(name)
        self.gain = gain

    def __call__(self, verbose=False):
        input = self.links[0].get_value()
        self.value = input * self.gain
        return super().__call__(verbose)

    def summary(self):
        super().summary(f' gain {self.gain}')


# Cell
class Integration(BaseFunction):
    "Integration function."
    def __init__(self, gain, slow, name="integration"):
        super().__init__(name)
        self.gain = gain
        self.slow = slow

    def __call__(self, verbose=False):
        input = self.links[0].get_value()
        self.value = self.value +  ((input * self.gain) - self.value)/self.slow

        return super().__call__(verbose)


    def summary(self):
        super().summary(f'gain {self.gain} slow {self.slow} ')


# Cell
class PCTNode():
    "A single PCT controller."
    def __init__(self, perception, name="pctnode", history=False):
        self.links_built = False
        if history:
            self.history = PCTNodeData()
        self.name=name
        self.perceptionCollection = [perception]
        reference = Constant(1)
        self.referenceCollection = [reference]
        comparator = Subtract()
        self.comparatorCollection = [comparator]
        self.outputCollection = [Proportional(10)]

    def __call__(self, verbose=False):
        if not self.links_built:
            self.build_links()

        for referenceFunction in self.referenceCollection:
            referenceFunction(verbose)

        for perceptionFunction in self.perceptionCollection:
            perceptionFunction(verbose)

        for comparatorFunction in self.comparatorCollection:
            comparatorFunction(verbose)

        for outputFunction in self.outputCollection:
            outputFunction(verbose)

        self.output = self.outputCollection[-1].get_value()

        if verbose:
            print()

        if not self.history == None:
            self.history.add_data(self)

        return self.output

    def build_links(self):
        if len(self.referenceCollection)>0:
            link = self.referenceCollection[0]
            for i in range (1, len(self.referenceCollection)):
                self.referenceCollection[i].add_link(link)
                link = self.referenceCollection[i]

        if len(self.perceptionCollection)>0:
            link = self.perceptionCollection[0]
            for i in range (1, len(self.perceptionCollection)):
                self.perceptionCollection[i].add_link(link)
                link = self.perceptionCollection[i]

        self.comparatorCollection[0].add_link(self.referenceCollection[-1])
        self.comparatorCollection[0].add_link(self.perceptionCollection[-1])

        if len(self.comparatorCollection)>1:
            link = self.comparatorCollection[1]
            for i in range (1, len(self.comparatorCollection)):
                self.comparatorCollection[i].add_link(link)
                link = self.comparatorCollection[i]

        self.outputCollection[0].add_link(self.comparatorCollection[-1])

        if len(self.outputCollection)>0:
            link = self.outputCollection[0]
            for i in range (1, len(self.outputCollection)):
                self.outputCollection[i].add_link(link)
                link = self.outputCollection[i]

        self.links_built = True

    def run(self, steps=None, verbose=False):
        for i in range(steps):
            out = self(verbose)
        return out

    def set_output(self, value):
        self.outputCollection[-1].set_value(value)

    def get_output_function(self):
        return self.outputCollection[-1]


    def set_function_name(self, collection, position, name):
        if collection == "refcoll":
            self.referenceCollection[position].set_name(name)

    def summary(self):
        if not self.links_built:
            self.build_links()

        print(self.name, type(self).__name__)
        print("----------------------------")
        print("REF:", end=" ")
        for referenceFunction in self.referenceCollection:
            referenceFunction.summary()

        print("PER:", end=" ")
        for perceptionFunction in self.perceptionCollection:
            perceptionFunction.summary()

        print("COM:", end=" ")
        for comparatorFunction in self.comparatorCollection:
            comparatorFunction.summary()

        print("OUT:", end=" ")
        for outputFunction in self.outputCollection:
            outputFunction.summary()

        print("----------------------------")


# Cell
class PCTNodeData():
    "Data collected for a PCTNode"
    def __init__(self, name="pctnodedata"):
        self.data = {
            "refcoll":{},
            "percoll":{},
            "comcoll":{},
            "outcoll":{}}


    def add_data(self, node):
        ctr = 0

        self.add_collection( node.referenceCollection, "refcoll")
        self.add_collection( node.perceptionCollection, "percoll")
        self.add_collection( node.comparatorCollection, "comcoll")
        self.add_collection( node.outputCollection, "outcoll")

    def add_collection(self, collection, collname):
        for func in collection:
            if self.data[collname].get(func.get_name()) == None:
                dlist=[]
                cdict={func.get_name():dlist}
                self.data[collname]=cdict
            else:
                dlist = self.data[collname][func.get_name()]

            dlist.append(func.get_value())
