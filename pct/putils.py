# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01_putils.ipynb (unless otherwise specified).

__all__ = ['UniqueNamer', 'FunctionsList', 'get_drive', 'stringIntListToListOfInts', 'stringFloatListToListOfFloats',
           'stringListToListOfStrings', 'listNumsToString', 'sigmoid', 'smooth', 'is_in_notebooks']

# Cell
import os
import numpy as np

# Cell
class UniqueNamer:
    "A utility for ensuring the names of functions are unique."
    __instance = None
    @staticmethod
    def getInstance():
      """ Static access method. """
      if UniqueNamer.__instance == None:
         UniqueNamer()
      return UniqueNamer.__instance

    def __init__(self):
      """ Virtually private constructor. """
      if UniqueNamer.__instance != None:
         raise Exception("This class is a singleton!")
      else:
         UniqueNamer.__instance = self
      self.names = {}

    def clear(self):
      self.names = {}

    def get_name(self, name):
        if name in self.names.keys():
            num = self.names[name]+1
            self.names[name]=num
            name = f'{name}{num}'
        #else:
        self.names[name]=0
        return name

# Cell
class FunctionsList:
    "A utility for storing functions created, keyed on the function name."
    __instance = None
    @staticmethod
    def getInstance():
      """ Static access method. """
      if FunctionsList.__instance == None:
         FunctionsList()
      return FunctionsList.__instance
    def __init__(self):
      """ Virtually private constructor. """
      if FunctionsList.__instance != None:
         raise Exception("This class is a singleton!")
      else:
         FunctionsList.__instance = self
      self.functions = {}

    def clear(self):
      self.functions = {}

    def add_function(self, func):
        name = func.get_name()
        self.functions[name]=func

        return name

    def remove_function(self, name):
        self.functions.pop(name)

    def get_function(self, name):
        if isinstance(name, str) and name in self.functions:
            func = self.functions[name]
        else:
            func = name
        return func

    def report(self, name=None):
        if name == None:
            print(len(self.functions))
            for key in self.functions.keys():
                print("*** ", key, [self.functions[key]])
                print(self.functions[key])
        else:
            print("*** ", key, [self.functions[key]])
            print(self.functions[key])


# Cell
def get_drive():
    if os.name == 'nt':
        drive = os.path.abspath(os.sep)
    else:
        drive = os.path.abspath(os.sep)+'mnt'+os.sep+'c'+os.sep
    return drive

# Cell
def stringIntListToListOfInts(strList, delimiter):
    #listRes = list(strList.split(","))
    #print(listRes)
    result = []
    for item in strList.strip('][').split(','):
        result.append(int(item))
    return result

# Cell
def stringFloatListToListOfFloats(strList, delimiter):
    #listRes = list(strList.split(","))
    #print(listRes)
    result = []
    for item in strList.strip('][').split(','):
        result.append(float(item))
    return result

# Cell
def stringListToListOfStrings(strList, delimiter):
    #listRes = list(strList.split(","))
    #print(listRes)
    result = []
    for item in strList.strip('][').split(','):
        result.append(item.strip())
    return result

# Cell
def listNumsToString(list):
    str = ""
    for item in list:
        str += f'{item}'
    return str

# Cell
def sigmoid(x, range, scale) :
    return -range / 2 + range / (1 + np.exp(-x * scale / range));

# Cell
def smooth(new_val, old_val, smooth_factor):
    return old_val * smooth_factor + new_val * (1-smooth_factor)

# Cell
import os
from pathlib import Path

def is_in_notebooks():
    term = os.getenv('TERM')
    if term == 'xterm-color':
        return True

    return False