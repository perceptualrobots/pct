# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/06_architectures.ipynb (unless otherwise specified).

__all__ = ['BaseArchitecture', 'ProportionalArchitecture', 'StructureDefinition', 'BinaryOnes', 'BaseParameterType',
           'Binary', 'Float', 'Literal', 'ParameterFactory']

# Cell
import random
import numpy as np
import json
import os
import enum
from abc import ABC, abstractmethod

from .hierarchy import PCTHierarchy
from .nodes import PCTNode
from .functions import WeightedSum
from .functions import IndexedParameter
from .functions import Constant
from .environments import PendulumV0

# Cell
class BaseArchitecture(ABC):
    "Base class of an array architecture. This class is not used direclty by developers, but defines the functionality common to all."
    def __init__(self, name, config, env, inputs, history, error_collector):
        self.config = config
        self.env = env
        self.inputs=inputs
        self.hpct = PCTHierarchy(history=history, error_collector=error_collector)
        self.hpct.add_preprocessor(env)

        for input in inputs:
            self.hpct.add_preprocessor(input)

    def __call__(self):
        #level0config = self.config['level0']
        previous_columns=self.configure_zerothlevel()

        intermediate_levels = len(self.config)-3
        level=-1
        for level in range(intermediate_levels):
            leveln = self.config[f'level{level+1}']
            levelcolumns = self.configure_level(leveln, previous_columns, level+1)
            previous_columns=levelcolumns
        if intermediate_levels < 0:
            self.set_references()
        else:
            level+=1
            self.configure_top_level(self.config[f'level{level+1}'], level+1)

    def get_hierarchy(self):
        return self.hpct




# Cell
class ProportionalArchitecture(BaseArchitecture):
    "Proportional Architecture"
    def __init__(self, name="proportional", config=None, env=None, input_indexes=None, history=False, error_collector=None, **cargs):
        inputs=[]
        for ctr in range(len(input_indexes)):
            ip = IndexedParameter(index=input_indexes[ctr], name=f'Input{ctr}', links=[env])
            inputs.append(ip)

        super().__init__(name, config, env, inputs, history, error_collector)

    def configure_zerothlevel(self):
        inputsIndex=0
        outputsIndex=1
        actionsIndex=2

        config=self.config['level0']
        level=0
        numInputs= len(self.inputs)
        columns = len(config[inputsIndex][0])
        #print(config[0][0])
        #print(columns)

        # create nodes
        for column in range(columns):
            node = PCTNode(build_links=True, mode=1, name=f'L{level}C{column}', history=self.hpct.history)
            # change names
            node.get_function("perception").set_name(f'PL{level}C{column}ws')
            node.get_function("reference").set_name(f'RL{level}C{column}ws')
            node.get_function("comparator").set_name(f'CL{level}C{column}')
            node.get_function("output").set_name(f'OL{level}C{column}p')

            weights=[]
            # configure perceptions
            for inputIndex in range(numInputs):
                node.get_function("perception").add_link(self.inputs[inputIndex])
                weights.append(config[inputsIndex][inputIndex][column])
            node.get_function("perception").weights=np.array(weights)

            # configure outputs
            node.get_function("output").set_property('gain', config[outputsIndex][column])

            self.hpct.add_node(node, level, column)

        # configure actions
        numActions = len(config[actionsIndex])
        numColumnsThisLevel = len(config[outputsIndex])
        for actionIndex in range(numActions):
            action = WeightedSum(weights=config[actionsIndex][actionIndex], name=f'Action{actionIndex+1}ws')
            for column in range(numColumnsThisLevel):
                action.add_link(f'OL{level}C{column}p')
            self.hpct.add_postprocessor(action)
            self.env.add_link(action)

        return numColumnsThisLevel

    def configure_level(self, config, numColumnsPreviousLevel, level):
        inputsIndex=0
        outputsIndex=1
        referencesIndex=2

        #numColumnsPreviousLevel=len(config[referencesIndex])
        numColumnsThisLevel = len(config[outputsIndex])

        # create nodes
        for column in range(numColumnsThisLevel):
            node = PCTNode(build_links=True, mode=1, name=f'L{level}C{column}', history=self.hpct.history)
            # change names
            node.get_function("perception").set_name(f'PL{level}C{column}ws')
            node.get_function("reference").set_name(f'RL{level}C{column}ws')
            node.get_function("comparator").set_name(f'CL{level}C{column}')
            node.get_function("output").set_name(f'OL{level}C{column}p')

            weights=[]
            # configure perceptions
            for inputIndex in range(numColumnsPreviousLevel):
                node.get_function("perception").add_link(f'PL{level-1}C{inputIndex}ws')
                weights.append(config[inputsIndex][column][inputIndex])

            node.get_function("perception").weights=np.array(weights)

            # configure outputs
            node.get_function("output").set_property('gain', config[outputsIndex][column])

            self.hpct.add_node(node, level, column)

        # configure lower references
        for referenceIndex in range(numColumnsPreviousLevel):
            reference = self.hpct.get_function(level-1, referenceIndex, "reference")
            weights=[]

            for output_column in range(numColumnsThisLevel):
                reference.add_link(f'OL{level}C{output_column}p')
                weights.append(config[referencesIndex][referenceIndex][output_column])

            reference.weights=np.array(weights)

        return numColumnsThisLevel

    def configure_top_level(self, config, level):
        inputsIndex=0
        outputsIndex=1
        lowerReferencesIndex=2
        topReferencesIndex=3

        numColumnsThisLevel = len(config[topReferencesIndex])
        numColumnsPreviousLevel=len(config[lowerReferencesIndex])

        # create nodes
        for column in range(numColumnsThisLevel):
            node = PCTNode(build_links=True, mode=2, name=f'L{level}C{column}', history=self.hpct.history)
            # change names
            reference = Constant(config[topReferencesIndex][column], name=f'RL{level}C{column}c')
            node.replace_function("reference", reference, 0)
            node.get_function("perception").set_name(f'PL{level}C{column}ws')
            #node.get_function("reference").set_name(f'RL{level}C{column}ws')
            node.get_function("comparator").set_name(f'CL{level}C{column}')
            node.get_function("output").set_name(f'OL{level}C{column}p')
            node.get_function("comparator").set_link(reference)
            node.get_function("comparator").add_link(node.get_function("perception"))

            # set reference value
            #node.get_function("reference").set_property('value', config[topReferencesIndex][column])


            weights=[]
            # configure perceptions
            for inputIndex in range(numColumnsPreviousLevel):
                node.get_function("perception").add_link(f'PL{level-1}C{inputIndex}ws')
                weights.append(config[inputsIndex][column][inputIndex])
                #weights.append(config[inputsIndex][inputIndex][column])
            node.get_function("perception").weights=np.array(weights)

            # configure outputs
            node.get_function("output").set_property('gain', config[outputsIndex][column])

            self.hpct.add_node(node, level, column)

        # configure lower references
        for referenceIndex in range(numColumnsPreviousLevel):
            reference = self.hpct.get_function(level-1, referenceIndex, "reference")
            weights=[]

            for output_column in range(numColumnsThisLevel):
                reference.add_link(f'OL{level}C{output_column}p')
                weights.append(config[lowerReferencesIndex][referenceIndex][output_column])

            reference.weights=np.array(weights)


    def set_references(self):
        level=0
        config=self.config['level0']
        topReferencesIndex=3

        numColumnsThisLevel = len(config[topReferencesIndex])
        # change nodes
        for column in range(numColumnsThisLevel):
            node = self.hpct.get_node(level, column)
            reference = Constant(config[topReferencesIndex][column], name=f'RL{level}C{column}c')
            node.replace_function("reference", reference, 0)
            node.get_function("comparator").set_link(reference)
            node.get_function("comparator").add_link(node.get_function("perception"))





# Cell
class StructureDefinition():
    "StructureDefinition"
    def __init__(self, config=None, **cargs):
        if config==None:
            self.config={'parameters': {'lower_float': -1, 'upper_float': 1, 'levels_limit': 3, 'columns_limit': 3},
                         'level0': {'perception': {'type': 'Binary'}, 'output': {'type': 'Float'}, 'reference': {'type': 'Float'}, 'action': {'type': 'Binary'}},
                         'leveln': {'perception': {'type': 'Binary'}, 'output': {'type': 'Float'}, 'reference': {'type': 'Float'}},
                         'leveltop': {'perception': {'type': 'Binary'}, 'output': {'type': 'Float'}, 'reference': {'type': 'Literal'}}}

        else:
            self.config=config

    def get_config(self):
        return self.config

    def add_config_type(self, level='n', function=None, type=None):
        #ttype={}
        #ttype[type]={'pars':{}}
        ttype={'type': type}
        self.config['level' + level][function]=ttype

    def add_structure_parameter(self, key=None, value=None):
        self.config['parameters'][key]=value



    def add_config_parameter(self, level='n', function=None,  parameter_type=None, parameter_value=None):
        if not 'pars' in self.config['level' + level][function]:
            self.config['level' + level][function]['pars']={} #pars={'pars'}
        self.config['level' + level][function]['pars'][parameter_type]=parameter_value

    def get_level0_config(self):
        return self.config['level0']

    def get_leveln_config(self):
        return self.config['leveln']

    def get_leveltop_config(self):
        return self.config['leveltop']

    def get_type(self, level, function):
        package = self.config[level][function]
        pars={}
        if 'pars' in package.keys():
            pars = package['pars']

        return package['type'], pars

    def get_type_parameters(self, level, function):
        return self.config[level][function]

    def get_parameter(self, key):
        return self.config['parameters'][key]


    def get_list(self, level, function,  num_lists, num_items):
        type, type_parameters = self.get_type(level, function)
        #print(perception_type, perception_type_parameters)

        parameter = ParameterFactory.createParameter(type)
        parameter.set_parameters(type_parameters, self.config['parameters'])
        list = parameter.get_weights_list(num_lists, num_items)

        return list

    def get_level0(self, num_inputs, numColumnsThisLevel, numColumnsNextLevel, num_actions):
        config0=[]

        perception_list = self.get_list('level0','perception', num_inputs, numColumnsThisLevel)

        output_list = self.get_list('level0','output', num_actions, numColumnsThisLevel)

        reference_list = self.get_list('level0','reference', numColumnsThisLevel, numColumnsNextLevel)

        action_list = self.get_list('level0','action', num_actions, numColumnsThisLevel)

        config0.append(perception_list)
        config0.append(output_list[0])
        config0.append(reference_list)
        config0.append(action_list)

        return config0


    def get_leveln(self, numColumnsThisLevel, numColumnsNextLevel, numColumnsPreviousLevel):
        config=[]

        perception_list = self.get_list('leveln','perception', numColumnsPreviousLevel, numColumnsThisLevel)

        output_list = self.get_list('leveln','output', numColumnsPreviousLevel, numColumnsThisLevel)

        reference_list = self.get_list('leveln','reference', numColumnsThisLevel, numColumnsNextLevel)


        config.append(perception_list)
        config.append(output_list[0])
        config.append(reference_list)

        return config

    def get_level0top(self, num_inputs, numColumnsThisLevel, num_actions):
        config0=[]

        perception_list = self.get_list('level0','perception', num_inputs, numColumnsThisLevel)

        output_list = self.get_list('level0','output', num_actions, numColumnsThisLevel)

        reference_list = self.get_list('leveltop','reference', 1, numColumnsThisLevel)

        action_list = self.get_list('level0','action', num_actions, numColumnsThisLevel)

        config0.append(perception_list)
        config0.append(output_list[0])
        config0.append(reference_list)
        config0.append(action_list)

        return config0

    def get_leveltop(self, numColumnsThisLevel, numColumnsPreviousLevel):
        config=[]

        perception_list = self.get_list('leveltop','perception', numColumnsPreviousLevel, numColumnsThisLevel)

        output_list = self.get_list('leveltop','output', 1, numColumnsThisLevel)

        reference_list = self.get_list('leveltop','reference', 1, numColumnsThisLevel)


        config.append(perception_list)
        config.append(output_list[0])
        config.append(reference_list)

        return config

# Cell
class BinaryOnes(enum.Enum):
   ALL_ONES = 1
   AT_LEAST_ONE = 2

class BaseParameterType(ABC):
    "Base class of a hierarchy parameter type. This class is not used direclty by developers, but defines the interface common to all."
    def __init__(self):
        pass

    def set_parameters(self, pars, globals):
        for par in pars:
            cmd = f'self.{par} = {pars[par]}'
            exec(cmd)

class Binary(BaseParameterType):

    def __init__(self):
        self.ones=BinaryOnes.AT_LEAST_ONE

    def get_weights_list(self, num_inputs, num_columns):
        wts_list=[]
        for i in range(num_inputs):
            if self.ones == BinaryOnes.ALL_ONES:
                wts = [1] * num_columns
            else:
                wts = [random.randint(0, 1) for iter in range(num_columns)]
                if self.ones == BinaryOnes.AT_LEAST_ONE:
                    if np.sum(wts) == 0:
                        index = random.randint(0, num_columns-1)
                        wts[index] = 1

            wts_list.append(wts)

        return wts_list

    class Factory:
        def create(self): return Binary()


class Float(BaseParameterType):

    def __init__(self):
        self.lower=None
        self.upper=None

    def get_weights_list(self,  num_lists, length):
        wts=[]
        for i in range(num_lists):
            wt = [random.uniform(self.lower, self.upper) for iter in range(length)]
            wts.append(wt)
        return wts

    def set_parameters(self, pars, globals):
        super().set_parameters(pars, globals)
        if self.lower==None:
            self.lower = globals['lower_float']
        if self.upper==None:
            self.upper = globals['upper_float']

    class Factory:
        def create(self): return Float()


class Literal(BaseParameterType):

    def __init__(self):
        self.value=None

    def get_weights_list(self,  num_lists, length):
        return self.value

    class Factory:
        def create(self): return Literal()


class ParameterFactory:
    factories = {}
    def addFactory(id, parameterFactory):
        ParameterFactory.factories.put[id] = parameterFactory
    addFactory = staticmethod(addFactory)

    # A Template Method:
    def createParameter(id):
        if not ParameterFactory.factories.__contains__(id):
            ParameterFactory.factories[id] = \
              eval(id + '.Factory()')
        return ParameterFactory.factories[id].create()

    createParameter = staticmethod(createParameter)