# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/06_architectures.ipynb (unless otherwise specified).

__all__ = ['BaseArchitecture', 'ProportionalArchitecture', 'BinaryOnes', 'BaseParameterType', 'Binary', 'Float',
           'Literal', 'ParameterFactory', 'StructureDefinition', 'DynamicArchitecture']

# Cell
import random
import numpy as np
import json
import os
import enum
from abc import ABC, abstractmethod

from .hierarchy import PCTHierarchy
from .nodes import PCTNode
from .functions import WeightedSum
from .functions import IndexedParameter
from .functions import Constant
from .environments import PendulumV0

# Cell
class BaseArchitecture(ABC):
    "Base class of an array architecture. This class is not used direclty by developers, but defines the functionality common to all."
    def __init__(self, name, config, env, inputs, history, error_collector):
        self.config = config
        self.env = env
        self.inputs=inputs
        self.hpct = PCTHierarchy(history=history, error_collector=error_collector)
        self.hpct.add_preprocessor(env)

        for input in inputs:
            self.hpct.add_preprocessor(input)

    def __call__(self):
        #level0config = self.config['level0']
        previous_columns=self.configure_zerothlevel()

        intermediate_levels = len(self.config)-3
        level=-1
        for level in range(intermediate_levels):
            leveln = self.config[f'level{level+1}']
            levelcolumns = self.configure_level(leveln, previous_columns, level+1)
            previous_columns=levelcolumns
        if intermediate_levels < 0:
            self.set_references()
        else:
            level+=1
            self.configure_top_level(self.config[f'level{level+1}'], level+1)

    def get_hierarchy(self):
        return self.hpct




# Cell
class ProportionalArchitecture(BaseArchitecture):
    "Proportional Architecture"
    def __init__(self, name="proportional", config=None, env=None, input_indexes=None, history=False, error_collector=None, **cargs):
        inputs=[]
        for ctr in range(len(input_indexes)):
            ip = IndexedParameter(index=input_indexes[ctr], name=f'Input{ctr}', links=[env])
            inputs.append(ip)

        super().__init__(name, config, env, inputs, history, error_collector)

    def configure_zerothlevel(self):
        inputsIndex=0
        outputsIndex=1
        actionsIndex=2

        config=self.config['level0']
        level=0
        numInputs= len(self.inputs)
        columns = len(config[inputsIndex][0])
        #print(config[0][0])
        #print(columns)

        # create nodes
        for column in range(columns):
            node = PCTNode(build_links=True, mode=1, name=f'L{level}C{column}', history=self.hpct.history)
            # change names
            node.get_function("perception").set_name(f'PL{level}C{column}ws')
            node.get_function("reference").set_name(f'RL{level}C{column}ws')
            node.get_function("comparator").set_name(f'CL{level}C{column}')
            node.get_function("output").set_name(f'OL{level}C{column}p')

            weights=[]
            # configure perceptions
            for inputIndex in range(numInputs):
                node.get_function("perception").add_link(self.inputs[inputIndex])
                weights.append(config[inputsIndex][inputIndex][column])
            node.get_function("perception").weights=np.array(weights)

            # configure outputs
            node.get_function("output").set_property('gain', config[outputsIndex][column])

            self.hpct.add_node(node, level, column)

        # configure actions
        numActions = len(config[actionsIndex])
        numColumnsThisLevel = len(config[outputsIndex])
        for actionIndex in range(numActions):
            action = WeightedSum(weights=config[actionsIndex][actionIndex], name=f'Action{actionIndex+1}ws')
            for column in range(numColumnsThisLevel):
                action.add_link(f'OL{level}C{column}p')
            self.hpct.add_postprocessor(action)
            self.env.add_link(action)

        return numColumnsThisLevel

    def configure_level(self, config, numColumnsPreviousLevel, level):
        inputsIndex=0
        outputsIndex=1
        referencesIndex=2

        #numColumnsPreviousLevel=len(config[referencesIndex])
        numColumnsThisLevel = len(config[outputsIndex])

        # create nodes
        for column in range(numColumnsThisLevel):
            node = PCTNode(build_links=True, mode=1, name=f'L{level}C{column}', history=self.hpct.history)
            # change names
            node.get_function("perception").set_name(f'PL{level}C{column}ws')
            node.get_function("reference").set_name(f'RL{level}C{column}ws')
            node.get_function("comparator").set_name(f'CL{level}C{column}')
            node.get_function("output").set_name(f'OL{level}C{column}p')

            weights=[]
            # configure perceptions
            for inputIndex in range(numColumnsPreviousLevel):
                node.get_function("perception").add_link(f'PL{level-1}C{inputIndex}ws')
                weights.append(config[inputsIndex][column][inputIndex])

            node.get_function("perception").weights=np.array(weights)

            # configure outputs
            node.get_function("output").set_property('gain', config[outputsIndex][column])

            self.hpct.add_node(node, level, column)

        # configure lower references
        for referenceIndex in range(numColumnsPreviousLevel):
            reference = self.hpct.get_function(level-1, referenceIndex, "reference")
            weights=[]

            for output_column in range(numColumnsThisLevel):
                reference.add_link(f'OL{level}C{output_column}p')
                weights.append(config[referencesIndex][referenceIndex][output_column])

            reference.weights=np.array(weights)

        return numColumnsThisLevel

    def configure_top_level(self, config, level):
        inputsIndex=0
        outputsIndex=1
        lowerReferencesIndex=2
        topReferencesIndex=3

        numColumnsThisLevel = len(config[topReferencesIndex])
        numColumnsPreviousLevel=len(config[lowerReferencesIndex])

        # create nodes
        for column in range(numColumnsThisLevel):
            node = PCTNode(build_links=True, mode=2, name=f'L{level}C{column}', history=self.hpct.history)
            # change names
            reference = Constant(config[topReferencesIndex][column], name=f'RL{level}C{column}c')
            node.replace_function("reference", reference, 0)
            node.get_function("perception").set_name(f'PL{level}C{column}ws')
            #node.get_function("reference").set_name(f'RL{level}C{column}ws')
            node.get_function("comparator").set_name(f'CL{level}C{column}')
            node.get_function("output").set_name(f'OL{level}C{column}p')
            node.get_function("comparator").set_link(reference)
            node.get_function("comparator").add_link(node.get_function("perception"))

            # set reference value
            #node.get_function("reference").set_property('value', config[topReferencesIndex][column])


            weights=[]
            # configure perceptions
            for inputIndex in range(numColumnsPreviousLevel):
                node.get_function("perception").add_link(f'PL{level-1}C{inputIndex}ws')
                weights.append(config[inputsIndex][column][inputIndex])
                #weights.append(config[inputsIndex][inputIndex][column])
            node.get_function("perception").weights=np.array(weights)

            # configure outputs
            node.get_function("output").set_property('gain', config[outputsIndex][column])

            self.hpct.add_node(node, level, column)

        # configure lower references
        for referenceIndex in range(numColumnsPreviousLevel):
            reference = self.hpct.get_function(level-1, referenceIndex, "reference")
            weights=[]

            for output_column in range(numColumnsThisLevel):
                reference.add_link(f'OL{level}C{output_column}p')
                weights.append(config[lowerReferencesIndex][referenceIndex][output_column])

            reference.weights=np.array(weights)


    def set_references(self):
        level=0
        config=self.config['level0']
        topReferencesIndex=3

        numColumnsThisLevel = len(config[topReferencesIndex])
        # change nodes
        for column in range(numColumnsThisLevel):
            node = self.hpct.get_node(level, column)
            reference = Constant(config[topReferencesIndex][column], name=f'RL{level}C{column}c')
            node.replace_function("reference", reference, 0)
            node.get_function("comparator").set_link(reference)
            node.get_function("comparator").add_link(node.get_function("perception"))





# Cell


class BinaryOnes(enum.Enum):
   ALLOW_ALL_ZEROS = 0
   ALL_ONES = 1
   AT_LEAST_ONE = 2

class BaseParameterType(ABC):
    "Base class of a hierarchy parameter type. This class is not used direclty by developers, but defines the interface common to all."
    def __init__(self):
        pass

    def set_parameters(self, pars, globals):
        for par in pars:
            cmd = f'self.{par} = {pars[par]}'
            exec(cmd)

    def set_node_function(self, node, function, thislevel, targetlevel, targetprefix, column, num_target_indices, inputs, input_weights, by_column):
        func = node.get_function(function)
        prefix = function[0].capitalize()
        func.set_name(f'{prefix}L{thislevel}C{column}ws')

        """
        print('Base',func.get_name())
        print('Base',inputs)
        print('Base',input_weights)
        print('Base',column)
        print('Base',num_target_indices)
        """
        weights=[]
        for inputIndex in range(num_target_indices):
            if inputs==None:
                name=f'{targetprefix}L{targetlevel}C{inputIndex}ws'
            else:
                name=inputs[inputIndex]
            func.add_link(name)
            #print(name)
            if by_column:
                weights.append(input_weights[column][inputIndex])
            else:
                #print(inputIndex,column)
                weights.append(input_weights[inputIndex][column])
        func.weights=np.array(weights)

    def has_changed(self, wts1, wts2):
        mutated = 0
        if wts1 != wts2:
            mutated = 1
        return mutated



class Binary(BaseParameterType):

    def __init__(self):
        self.ones=BinaryOnes.AT_LEAST_ONE
        self.attr_mut_pb=None

    def get_weights_list(self, num_inputs, num_columns):
        wts_list=[]
        for i in range(num_inputs):
            if self.ones == BinaryOnes.ALL_ONES:
                wts = [1] * num_columns
            else:
                wts = [random.randint(0, 1) for iter in range(num_columns)]
                if self.ones == BinaryOnes.AT_LEAST_ONE:
                    if np.sum(wts) == 0:
                        index = random.randint(0, num_columns-1)
                        wts[index] = 1

            wts_list.append(wts)

        return wts_list

    def set_parameters(self, pars, globals):
        super().set_parameters(pars, globals)
        if self.attr_mut_pb==None:
            self.attr_mut_pb= globals['attr_mut_pb']


    def mutate(self, wts):
        if self.ones == BinaryOnes.ALL_ONES or (self.ones == BinaryOnes.AT_LEAST_ONE and len(wts)==1):
            pass
        else:
            weights, = tools.mutFlipBit(wts, self.attr_mut_pb)
            if self.ones == BinaryOnes.AT_LEAST_ONE:
                if np.sum(weights) == 0:
                    index = random.randint(0, len(weights)-1)
                    weights[index] = 1

    def copy_data(self, from_wts, to_wts):

        #print(from_wts, to_wts)
        from_len=len(from_wts)
        to_len = len(to_wts)

        for ctr in range(min(from_len, to_len)):
            to_wts[ctr] = from_wts[ctr]

        if self.ones == BinaryOnes.AT_LEAST_ONE:
            if np.sum(to_wts) == 0:
                index = random.randint(0, len(to_wts)-1)
                to_wts[index] = 1


        #return to_wts


    class Factory:
        def create(self): return Binary()


class Float(BaseParameterType):

    def __init__(self):
        self.lower=None
        self.upper=None
        self.mu=None
        self.sigma=None
        self.attr_mut_pb=None

    def get_weights_list(self,  num_lists, length):
        wts=[]
        for i in range(num_lists):
            wt = [random.uniform(self.lower, self.upper) for iter in range(length)]
            wts.append(wt)
        return wts

    def set_parameters(self, pars, globals):
        super().set_parameters(pars, globals)
        if self.lower==None:
            self.lower = globals['lower_float']
        if self.upper==None:
            self.upper = globals['upper_float']
        if self.mu==None:
            self.mu = globals['mu']
        if self.sigma==None:
            self.sigma= globals['sigma']
        if self.attr_mut_pb==None:
            self.attr_mut_pb= globals['attr_mut_pb']

    def mutate(self, wts):
        weights, = tools.mutGaussian(wts, mu=self.mu, sigma=self.sigma, indpb=self.attr_mut_pb)

    def copy_data(self, from_wts, to_wts):

        #print(from_wts, to_wts)
        from_len=len(from_wts)
        to_len = len(to_wts)

        for ctr in range(min(from_len, to_len)):
            to_wts[ctr] = from_wts[ctr]





    class Factory:
        def create(self): return Float()


class Literal(BaseParameterType):

    def __init__(self):
        self.value=None

    def get_weights_list(self,  num_lists, length):
        return self.value

    def set_node_function(self, node, function, thislevel, targetlevel, not_used, column, not_used1, inputs, weights, not_used2):

        func = node.get_function(function)
        prefix = function[0].capitalize()
        func.set_name(f'{prefix}L{thislevel}C{column}c')
        """
        print('Literal',inputs)
        print('Literal',weights)
        prefix = function[0].capitalize()
        constant = Constant(weights[column], name=f'{prefix}L{thislevel}C{column}c')
        node.replace_function(function, constant, 0)
        """

    def copy_data(self, from_wts, to_wts):
        pass

    class Factory:
        def create(self): return Literal()


class ParameterFactory:
    factories = {}
    def addFactory(id, parameterFactory):
        ParameterFactory.factories.put[id] = parameterFactory
    addFactory = staticmethod(addFactory)

    # A Template Method:
    def createParameter(id):
        if not ParameterFactory.factories.__contains__(id):
            ParameterFactory.factories[id] = \
              eval(id + '.Factory()')
        return ParameterFactory.factories[id].create()

    createParameter = staticmethod(createParameter)

class StructureDefinition():
    "StructureDefinition"
    def __init__(self, config=None, attr_mut_pb=None, **cargs):
        if config==None:
            self.config={'parameters': {'lower_float': -1, 'upper_float': 1,
                            'levels_limit': 3, 'columns_limit': 3, 'attr_mut_pb': 1.0, 'sigma': 0.8, 'mu': 0.5},
                         'level0': {'perception': {'type': 'Binary'}, 'output': {'type': 'Float'}, 'reference': {'type': 'Float'}, 'action': {'type': 'Binary'}},
                         'leveln': {'perception': {'type': 'Binary'}, 'output': {'type': 'Float'}, 'reference': {'type': 'Float'}},
                         'leveltop': {'perception': {'type': 'Binary'}, 'output': {'type': 'Float'}, 'reference': {'type': 'Literal'}}}
        else:
            self.config=config

        if attr_mut_pb != None:
            self.config['parameters']['attr_mut_pb']=attr_mut_pb


    def get_config(self):
        return self.config

    def add_config_type(self, level='n', function=None, type=None):
        #ttype={}
        #ttype[type]={'pars':{}}
        ttype={'type': type}
        self.config['level' + level][function]=ttype

    def add_structure_parameter(self, key=None, value=None):
        self.config['parameters'][key]=value



    def add_config_parameter(self, level='n', function=None,  parameter_type=None, parameter_value=None):
        if not 'pars' in self.config['level' + level][function]:
            self.config['level' + level][function]['pars']={} #pars={'pars'}
        self.config['level' + level][function]['pars'][parameter_type]=parameter_value

    def get_level0_config(self):
        return self.config['level0']

    def get_leveln_config(self):
        return self.config['leveln']

    def get_leveltop_config(self):
        return self.config['leveltop']

    def get_type(self, level, function):
        package = self.config[level][function]
        pars={}
        if 'pars' in package.keys():
            pars = package['pars']

        return package['type'], pars

    def get_type_parameters(self, level, function):
        return self.config[level][function]

    def get_parameter(self, key):
        return self.config['parameters'][key]


    def set_node_function(self, node, function, levelkey, thislevel, targetlevel, targetprefix, column, num_target_indices, inputs, input_weights, by_column):
        type, type_parameters = self.get_type(levelkey, function)

        parameter = ParameterFactory.createParameter(type)
        #parameter.set_parameters(type_parameters, self.config['parameters'])
        #list = parameter.get_weights_list(num_lists, num_items)
        parameter.set_node_function(node, function,  thislevel, targetlevel, targetprefix, column, num_target_indices, inputs, input_weights, by_column)



    def get_list(self, level, function,  num_lists, num_items):
        parameter = self.get_paramter_object(level, function)
        return parameter.get_weights_list(num_lists, num_items)


    def mutate_list(self, level, function, wts):
        parameter = self.get_paramter_object(level, function)
        return parameter.mutate(wts)

    def copy_data(self, level, function, from_wts, to_wts):
        parameter = self.get_paramter_object(level, function)
        parameter.copy_data(from_wts, to_wts)

    def get_paramter_object(self, level, function):
        type, type_parameters = self.get_type(level, function)

        parameter = ParameterFactory.createParameter(type)
        parameter.set_parameters(type_parameters, self.config['parameters'])

        return parameter


    def get_level0(self, num_inputs, numColumnsThisLevel, numColumnsNextLevel, num_actions):
        config0=[]

        perception_list = self.get_list('level0','perception', num_inputs, numColumnsThisLevel)
        output_list = self.get_list('level0','output', num_actions, numColumnsThisLevel)
        reference_list = self.get_list('level0','reference', numColumnsThisLevel, numColumnsNextLevel)
        action_list = self.get_list('level0','action', num_actions, numColumnsThisLevel)

        config0.append(perception_list)
        config0.append(output_list[0])
        config0.append(reference_list)
        config0.append(action_list)

        return config0


    def get_leveln(self, numColumnsThisLevel, numColumnsNextLevel, numColumnsPreviousLevel):
        config=[]

        perception_list = self.get_list('leveln','perception', numColumnsPreviousLevel, numColumnsThisLevel)

        output_list = self.get_list('leveln','output', numColumnsPreviousLevel, numColumnsThisLevel)

        reference_list = self.get_list('leveln','reference', numColumnsThisLevel, numColumnsNextLevel)


        config.append(perception_list)
        config.append(output_list[0])
        config.append(reference_list)

        return config

    def get_level0top(self, num_inputs, numColumnsThisLevel, num_actions):
        config0=[]

        perception_list = self.get_list('level0','perception', num_inputs, numColumnsThisLevel)

        output_list = self.get_list('level0','output', num_actions, numColumnsThisLevel)

        reference_list = self.get_list('leveltop','reference', 1, numColumnsThisLevel)

        action_list = self.get_list('level0','action', num_actions, numColumnsThisLevel)

        config0.append(perception_list)
        config0.append(output_list[0])
        config0.append(reference_list)
        config0.append(action_list)

        return config0

    def get_leveltop(self, numColumnsThisLevel, numColumnsPreviousLevel):
        config=[]

        perception_list = self.get_list('leveltop','perception', numColumnsPreviousLevel, numColumnsThisLevel)

        output_list = self.get_list('leveltop','output', 1, numColumnsThisLevel)

        reference_list = self.get_list('leveltop','reference', 1, numColumnsThisLevel)


        config.append(perception_list)
        config.append(output_list[0])
        config.append(reference_list)

        return config

    def set_action_function(self, hpct, env, numColumnsThisLevel,  weights):
        numActions = len(weights)
        for actionIndex in range(numActions):
            action = WeightedSum(weights=weights[actionIndex], name=f'Action{actionIndex+1}ws')
            for column in range(numColumnsThisLevel):
                action.add_link(f'OL0C{column}ws')
            hpct.add_postprocessor(action)
            env.add_link(action)



class DynamicArchitecture(BaseArchitecture):
    "Dynamic Architecture"
    def __init__(self, name="proportional", structure=None, config=None, env=None, input_indexes=None, history=False, error_collector=None, **cargs):
        inputs=[]
        for ctr in range(len(input_indexes)):
            ip = IndexedParameter(index=input_indexes[ctr], name=f'Input{ctr}', links=[env])
            inputs.append(ip)

        super().__init__(name, config, env, inputs, history, error_collector)
        self.structure=structure

    def __call__(self):
        #level0config = self.config['level0']
        levels = len(self.config)-1
        #print('levels', levels)
        if levels == 1:
            self.configure_zerotoplevel()
        else:
            previous_columns=self.configure_zerothlevel()

            intermediate_levels = len(self.config)-3
            level=-1
            for level in range(intermediate_levels):
                leveln = self.config[f'level{level+1}']
                levelcolumns = self.configure_level(leveln, previous_columns, level+1)
                previous_columns=levelcolumns
            if intermediate_levels < 0:
                self.set_references()
            else:
                level+=1
                self.configure_top_level(self.config[f'level{level+1}'], level+1, previous_columns)


    def configure_zerotoplevel(self):
        inputsIndex=0
        outputsIndex=1
        referencesIndex=2
        actionsIndex=3

        config=self.config['level0']
        level=0
        #numInputs= len(self.inputs)
        columns = len(config[inputsIndex][0])
        #print(config[0][0])
        #print('columns',columns)

        # create nodes
        for column in range(columns):
            node = PCTNode(build_links=True, mode=4, name=f'L{level}C{column}', history=self.hpct.history)
            self.structure.set_node_function(node, 'reference',  'leveltop', level, None, None, column, None, None, config[referencesIndex], True)
            self.structure.set_node_function(node, 'perception', 'level0', level, None, None, column, len(self.inputs), self.inputs, config[inputsIndex], False)

            comparator_name=f'CL{level}C{column}'
            node.get_function("comparator").set_name(comparator_name)
            node.get_function("comparator").set_link(node.get_function("reference"))
            node.get_function("comparator").add_link(node.get_function("perception"))

            self.structure.set_node_function(node, 'output',  'leveltop', level, None, 'C',  column, 1, [comparator_name], [config[outputsIndex]], False)

            self.hpct.add_node(node, level, column)

        # configure actions
        numColumnsThisLevel = len(config[outputsIndex])
        self.structure.set_action_function(self.hpct, self.env, numColumnsThisLevel, config[actionsIndex])

        return numColumnsThisLevel

    def configure_zerothlevel(self):
        inputsIndex=0
        outputsIndex=1
        referencesIndex=2
        actionsIndex=3

        config=self.config['level0']
        level=0
        columns = len(config[inputsIndex][0])
        #print(config[0][0])
        #print(columns)
        columnsNextLevel = len(config[referencesIndex][0])
        #print('columnsNextLevel',columnsNextLevel)

        # create nodes
        for column in range(columns):
            node = PCTNode(build_links=True, mode=3, name=f'L{level}C{column}', history=self.hpct.history)
            self.structure.set_node_function(node, 'reference',  'level0', level, level+1, 'O', column, columnsNextLevel, None, config[referencesIndex], True)
            self.structure.set_node_function(node, 'perception', 'level0', level, None, None, column, len(self.inputs), self.inputs, config[inputsIndex], False)

            comparator_name=f'CL{level}C{column}'
            node.get_function("comparator").set_name(comparator_name)

            self.structure.set_node_function(node, 'output',  'level0', level, None, 'C',  column, 1, [comparator_name], [config[outputsIndex]], False)

            self.hpct.add_node(node, level, column)

        # configure actions
        numColumnsThisLevel = len(config[outputsIndex])
        self.structure.set_action_function(self.hpct, self.env, numColumnsThisLevel, config[actionsIndex])

        return numColumnsThisLevel

    def configure_level(self, config, numColumnsPreviousLevel, level):
        inputsIndex=0
        outputsIndex=1
        referencesIndex=2

        #numColumnsPreviousLevel=len(config[referencesIndex])
        numColumnsThisLevel = len(config[outputsIndex])
        columnsNextLevel = len(config[referencesIndex][0])

        # create nodes
        for column in range(numColumnsThisLevel):
            node = PCTNode(build_links=True, mode=3, name=f'L{level}C{column}', history=self.hpct.history)
            self.structure.set_node_function(node, 'reference',  'leveln', level, level+1, 'O', column, columnsNextLevel, None, config[referencesIndex], True)
            self.structure.set_node_function(node, 'perception', 'leveln', level, level-1, 'P', column, numColumnsPreviousLevel, None, config[inputsIndex], False)

            comparator_name=f'CL{level}C{column}'
            node.get_function("comparator").set_name(comparator_name)

            self.structure.set_node_function(node, 'output',  'leveln', level, None, 'C',  column, 1, [comparator_name], [config[outputsIndex]], False)

            self.hpct.add_node(node, level, column)

        return numColumnsThisLevel

    def configure_top_level(self, config, level, numColumnsPreviousLevel ):
        inputsIndex=0
        outputsIndex=1
        referencesIndex=2

        numColumnsThisLevel = len(config[referencesIndex])

        # create nodes
        for column in range(numColumnsThisLevel):
            node = PCTNode(build_links=True, mode=4, name=f'L{level}C{column}', history=self.hpct.history)

            self.structure.set_node_function(node, 'reference',  'leveltop', level, None, None, column, None, None, config[referencesIndex], None)
            self.structure.set_node_function(node, 'perception', 'leveltop', level, level-1, 'P', column, numColumnsPreviousLevel, None, config[inputsIndex], False)

            comparator_name=f'CL{level}C{column}'
            node.get_function("comparator").set_name(comparator_name)
            node.get_function("comparator").set_link(node.get_function('reference'))
            node.get_function("comparator").add_link(node.get_function('perception'))

            self.structure.set_node_function(node, 'output',  'leveltop', level, None, 'C',  column, 1, [comparator_name], [config[outputsIndex]], False)

            self.hpct.add_node(node, level, column)



    def set_references(self):
        level=0
        config=self.config['level0']
        topReferencesIndex=3

        numColumnsThisLevel = len(config[topReferencesIndex])
        # change nodes
        for column in range(numColumnsThisLevel):
            node = self.hpct.get_node(level, column)
            reference = Constant(config[topReferencesIndex][column], name=f'RL{level}C{column}c')
            node.replace_function("reference", reference, 0)
            node.get_function("comparator").set_link(reference)
            node.get_function("comparator").add_link(node.get_function("perception"))
