# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_helpers.ipynb.

# %% auto 0
__all__ = ['ARCHelper']

# %% ../nbs/04_helpers.ipynb 3
import copy

# %% ../nbs/04_helpers.ipynb 4
class ARCHelper:
    def __init__(self, arc):
        self.arc = arc
        self.train_input_dims = []
        self.train_output_dims = []
        self.test_input_dims = []

        self._extract_dimensions()

    def _extract_dimensions(self):
        # Extract dimensions for train inputs and outputs
        for item in self.arc.get('train', []):
            input_dims = self._get_dimensions(item['input'])
            output_dims = self._get_dimensions(item['output'])
            self.train_input_dims.append(input_dims)
            self.train_output_dims.append(output_dims)

        # Extract dimensions for test inputs
        for item in self.arc.get('test', []):
            input_dims = self._get_dimensions(item['input'])
            self.test_input_dims.append(input_dims)

    def _get_dimensions(self, array):
        return (len(array), len(array[0]) if array else 0)

    def get_dimensions(self, primary_key, nested_key):
        if primary_key not in ['train', 'test']:
            raise ValueError("Primary key must be 'train' or 'test'")
        if nested_key not in ['input', 'output']:
            raise ValueError("Nested key must be 'input' or 'output'")

        if primary_key == 'train':
            if nested_key == 'input':
                return self.train_input_dims
            elif nested_key == 'output':
                return self.train_output_dims
        elif primary_key == 'test':
            if nested_key == 'input':
                return self.test_input_dims
            # The test data does not have 'output' dimensions
            else:
                raise ValueError("'output' key is not available for 'test'")

    def get_number_of_train_elements(self):
        return len(self.arc.get('train', []))

    def get_train_input_width(self, index):
        return self.train_input_dims[index][1]

    def get_train_input_height(self, index):
        return self.train_input_dims[index][0]

    def get_train_output_width(self, index):
        return self.train_output_dims[index][1]

    def get_train_output_height(self, index):
        return self.train_output_dims[index][0]

    def compare_with_train_output(self, index, array):
        if index >= len(self.arc.get('train', [])):
            raise IndexError("Index out of range for train data")
        
        train_output = self.arc['train'][index]['output']
        return train_output == array

    def metric(self, index, array):
        if index >= len(self.arc.get('train', [])):
            raise IndexError("Index out of range for train data")

        provided_height, provided_width = self._get_dimensions(array)
        train_output_height = self.get_train_output_height(index)
        train_output_width = self.get_train_output_width(index)

        height_ratio = provided_height / train_output_height
        width_ratio = provided_width / train_output_width

        return (height_ratio + width_ratio) / 2

    def add_or_remove_column(self, array, value, num_columns=1, add=True):
        for row in array:
            if add:
                row.extend([value] * num_columns)
            else:
                if len(row) >= num_columns:
                    row = row[:-num_columns]
                else:
                    row = []
        return array

    def add_or_remove_row(self, array, value, num_rows=1, add=True):
        if add:
            for _ in range(num_rows):
                array.append([value] * (len(array[0]) if array else 1))
        else:
            for _ in range(num_rows):
                if array:
                    array.pop()
        return array

    def clone_train_input(self, index):
        if index >= len(self.arc.get('train', [])):
            raise IndexError("Index out of range for train data")
        return copy.deepcopy(self.arc['train'][index]['input'])


    def get_dimensions_array(self, index):
        if index >= len(self.arc.get('train', [])):
            raise IndexError("Index out of range for train data")

        input_height, input_width = self.train_input_dims[index]
        output_height, output_width = self.train_output_dims[index]

        return [input_width, input_height, output_width, output_height]
    
    
